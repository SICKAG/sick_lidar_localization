/*
 * @brief sick_services implements the ROS services for sick localization.
 * It converts the ROS services to json, sends them to the localization server
 * using its REST API, receives the json response and returns the response data
 * converted to the service definition.
 *
 * Copyright (C) 2021 Ing.-Buero Dr. Michael Lehning, Hildesheim
 * Copyright (C) 2021 SICK AG, Waldkirch
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of SICK AG nor the names of its
 *       contributors may be used to endorse or promote products derived from
 *       this software without specific prior written permission
 *     * Neither the name of Ing.-Buero Dr. Michael Lehning nor the names of its
 *       contributors may be used to endorse or promote products derived from
 *       this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 *      Authors:
 *         Michael Lehning <michael.lehning@lehning.de>
 *
 *  Copyright 2021 SICK AG
 *  Copyright 2021 Ing.-Buero Dr. Michael Lehning
 *
 */
#include "sick_lidar_localization/sick_common.h"
#include "sick_lidar_localization/sick_services.h"
#include "sick_lidar_localization/SoftwarePLL.h"

#if __ROS_VERSION == 1 // ROS-1 services generated by ros_service_prep.py
#define serviceCbLocAutoStartSavePoseSrv sick_lidar_localization::SickServices::serviceCbLocAutoStartSavePoseSrvROS1
#define serviceCbLocClearMapCacheSrv sick_lidar_localization::SickServices::serviceCbLocClearMapCacheSrvROS1
#define serviceCbLocGetErrorLevelSrv sick_lidar_localization::SickServices::serviceCbLocGetErrorLevelSrvROS1
#define serviceCbLocGetMapSrv sick_lidar_localization::SickServices::serviceCbLocGetMapSrvROS1
#define serviceCbLocGetSystemStateSrv sick_lidar_localization::SickServices::serviceCbLocGetSystemStateSrvROS1
#define serviceCbLocInitializeAtPoseSrv sick_lidar_localization::SickServices::serviceCbLocInitializeAtPoseSrvROS1
#define serviceCbLocInitializePoseSrv sick_lidar_localization::SickServices::serviceCbLocInitializePoseSrvROS1
#define serviceCbLocIsSystemReadySrv sick_lidar_localization::SickServices::serviceCbLocIsSystemReadySrvROS1
#define serviceCbLocLoadMapToCacheSrv sick_lidar_localization::SickServices::serviceCbLocLoadMapToCacheSrvROS1
#define serviceCbLocRequestTimestampSrv sick_lidar_localization::SickServices::serviceCbLocRequestTimestampSrvROS1
#define serviceCbLocResumeAtPoseSrv sick_lidar_localization::SickServices::serviceCbLocResumeAtPoseSrvROS1
#define serviceCbLocSaveRingBufferRecordingSrv sick_lidar_localization::SickServices::serviceCbLocSaveRingBufferRecordingSrvROS1
#define serviceCbLocSetKinematicVehicleModelActiveSrv sick_lidar_localization::SickServices::serviceCbLocSetKinematicVehicleModelActiveSrvROS1
#define serviceCbLocSetLinesForSupportActiveSrv sick_lidar_localization::SickServices::serviceCbLocSetLinesForSupportActiveSrvROS1
#define serviceCbLocSetMappingActiveSrv sick_lidar_localization::SickServices::serviceCbLocSetMappingActiveSrvROS1
#define serviceCbLocSetMapSrv sick_lidar_localization::SickServices::serviceCbLocSetMapSrvROS1
#define serviceCbLocSetOdometryActiveSrv sick_lidar_localization::SickServices::serviceCbLocSetOdometryActiveSrvROS1
#define serviceCbLocSetRecordingActiveSrv sick_lidar_localization::SickServices::serviceCbLocSetRecordingActiveSrvROS1
#define serviceCbLocSetRingBufferRecordingActiveSrv sick_lidar_localization::SickServices::serviceCbLocSetRingBufferRecordingActiveSrvROS1
#define serviceCbLocStartLocalizingSrv sick_lidar_localization::SickServices::serviceCbLocStartLocalizingSrvROS1
#define serviceCbLocStateSrv sick_lidar_localization::SickServices::serviceCbLocStateSrvROS1
#define serviceCbLocStopSrv sick_lidar_localization::SickServices::serviceCbLocStopSrvROS1
#define serviceCbLocSwitchMapSrv sick_lidar_localization::SickServices::serviceCbLocSwitchMapSrvROS1
#define serviceCbLocGetLocalizationStatusSrv sick_lidar_localization::SickServices::serviceCbLocGetLocalizationStatusSrvROS1
#define serviceCbLocGetSoftwareVersionSrv sick_lidar_localization::SickServices::serviceCbLocGetSoftwareVersionSrvROS1
#define serviceCbLocLoadPersistentConfigSrv sick_lidar_localization::SickServices::serviceCbLocLoadPersistentConfigSrvROS1
//#define serviceCbLocSavePermanentSrv sick_lidar_localization::SickServices::serviceCbLocSavePermanentSrvROS1
#elif __ROS_VERSION == 2 // ROS-2 services generated by ros_service_prep.py
#define serviceCbLocAutoStartSavePoseSrv sick_lidar_localization::SickServices::serviceCbLocAutoStartSavePoseSrvROS2
#define serviceCbLocClearMapCacheSrv sick_lidar_localization::SickServices::serviceCbLocClearMapCacheSrvROS2
#define serviceCbLocGetErrorLevelSrv sick_lidar_localization::SickServices::serviceCbLocGetErrorLevelSrvROS2
#define serviceCbLocGetMapSrv sick_lidar_localization::SickServices::serviceCbLocGetMapSrvROS2
#define serviceCbLocGetSystemStateSrv sick_lidar_localization::SickServices::serviceCbLocGetSystemStateSrvROS2
#define serviceCbLocInitializeAtPoseSrv sick_lidar_localization::SickServices::serviceCbLocInitializeAtPoseSrvROS2
#define serviceCbLocInitializePoseSrv sick_lidar_localization::SickServices::serviceCbLocInitializePoseSrvROS2
#define serviceCbLocIsSystemReadySrv sick_lidar_localization::SickServices::serviceCbLocIsSystemReadySrvROS2
#define serviceCbLocLoadMapToCacheSrv sick_lidar_localization::SickServices::serviceCbLocLoadMapToCacheSrvROS2
#define serviceCbLocRequestTimestampSrv sick_lidar_localization::SickServices::serviceCbLocRequestTimestampSrvROS2
#define serviceCbLocResumeAtPoseSrv sick_lidar_localization::SickServices::serviceCbLocResumeAtPoseSrvROS2
#define serviceCbLocSaveRingBufferRecordingSrv sick_lidar_localization::SickServices::serviceCbLocSaveRingBufferRecordingSrvROS2
#define serviceCbLocSetKinematicVehicleModelActiveSrv sick_lidar_localization::SickServices::serviceCbLocSetKinematicVehicleModelActiveSrvROS2
#define serviceCbLocSetLinesForSupportActiveSrv sick_lidar_localization::SickServices::serviceCbLocSetLinesForSupportActiveSrvROS2
#define serviceCbLocSetMappingActiveSrv sick_lidar_localization::SickServices::serviceCbLocSetMappingActiveSrvROS2
#define serviceCbLocSetMapSrv sick_lidar_localization::SickServices::serviceCbLocSetMapSrvROS2
#define serviceCbLocSetOdometryActiveSrv sick_lidar_localization::SickServices::serviceCbLocSetOdometryActiveSrvROS2
#define serviceCbLocSetRecordingActiveSrv sick_lidar_localization::SickServices::serviceCbLocSetRecordingActiveSrvROS2
#define serviceCbLocSetRingBufferRecordingActiveSrv sick_lidar_localization::SickServices::serviceCbLocSetRingBufferRecordingActiveSrvROS2
#define serviceCbLocStartLocalizingSrv sick_lidar_localization::SickServices::serviceCbLocStartLocalizingSrvROS2
#define serviceCbLocStateSrv sick_lidar_localization::SickServices::serviceCbLocStateSrvROS2
#define serviceCbLocStopSrv sick_lidar_localization::SickServices::serviceCbLocStopSrvROS2
#define serviceCbLocSwitchMapSrv sick_lidar_localization::SickServices::serviceCbLocSwitchMapSrvROS2
#define serviceCbLocGetLocalizationStatusSrv sick_lidar_localization::SickServices::serviceCbLocGetLocalizationStatusSrvROS2
#define serviceCbLocGetSoftwareVersionSrv sick_lidar_localization::SickServices::serviceCbLocGetSoftwareVersionSrvROS2
#define serviceCbLocLoadPersistentConfigSrv sick_lidar_localization::SickServices::serviceCbLocLoadPersistentConfigSrvROS2
//#define serviceCbLocSavePermanentSrv sick_lidar_localization::SickServices::serviceCbLocSavePermanentSrvROS2
#endif

sick_lidar_localization::SickServices::SickServices(rosNodePtr nh, const std::string& hostname, const std::string& serverpath, int software_pll_fifo_length, int verbose)
: m_verbose(verbose)
{
    m_curl.init(hostname, serverpath, verbose);

    m_software_pll_fifo_length = software_pll_fifo_length;
    m_software_pll_name_send_time = "LocRequestTimestampSendTime";
    m_software_pll_name_recv_time = "LocRequestTimestampRecvTime";

    m_time_sync_rate = 0.1;
    m_time_sync_initial_rate = 1.0;
    m_time_sync_initial_length = 10;
    m_time_sync_thread_running = false;
    m_time_sync_thread = 0;

    if(nh)
    {
#if __ROS_VERSION > 0 // ros services generated by ros_service_prep.py
        auto srv_LocAutoStartSavePoseSrv = ROS_CREATE_SRV_SERVER(nh, sick_lidar_localization::LocAutoStartSavePoseSrv, "/LocAutoStartSavePose", &serviceCbLocAutoStartSavePoseSrv, this);
        m_srv_server_LocAutoStartSavePoseSrv = rosServiceServer<sick_lidar_localization::LocAutoStartSavePoseSrv>(srv_LocAutoStartSavePoseSrv);
        auto srv_LocClearMapCacheSrv = ROS_CREATE_SRV_SERVER(nh, sick_lidar_localization::LocClearMapCacheSrv, "/LocClearMapCache", &serviceCbLocClearMapCacheSrv, this);
        m_srv_server_LocClearMapCacheSrv = rosServiceServer<sick_lidar_localization::LocClearMapCacheSrv>(srv_LocClearMapCacheSrv);
        auto srv_LocGetErrorLevelSrv = ROS_CREATE_SRV_SERVER(nh, sick_lidar_localization::LocGetErrorLevelSrv, "/LocGetErrorLevel", &serviceCbLocGetErrorLevelSrv, this);
        m_srv_server_LocGetErrorLevelSrv = rosServiceServer<sick_lidar_localization::LocGetErrorLevelSrv>(srv_LocGetErrorLevelSrv);
        auto srv_LocGetMapSrv = ROS_CREATE_SRV_SERVER(nh, sick_lidar_localization::LocGetMapSrv, "/LocGetMap", &serviceCbLocGetMapSrv, this);
        m_srv_server_LocGetMapSrv = rosServiceServer<sick_lidar_localization::LocGetMapSrv>(srv_LocGetMapSrv);
        auto srv_LocGetSystemStateSrv = ROS_CREATE_SRV_SERVER(nh, sick_lidar_localization::LocGetSystemStateSrv, "/LocGetSystemState", &serviceCbLocGetSystemStateSrv, this);
        m_srv_server_LocGetSystemStateSrv = rosServiceServer<sick_lidar_localization::LocGetSystemStateSrv>(srv_LocGetSystemStateSrv);
        auto srv_LocInitializeAtPoseSrv = ROS_CREATE_SRV_SERVER(nh, sick_lidar_localization::LocInitializeAtPoseSrv, "/LocInitializeAtPose", &serviceCbLocInitializeAtPoseSrv, this);
        m_srv_server_LocInitializeAtPoseSrv = rosServiceServer<sick_lidar_localization::LocInitializeAtPoseSrv>(srv_LocInitializeAtPoseSrv);
        auto srv_LocIsSystemReadySrv = ROS_CREATE_SRV_SERVER(nh, sick_lidar_localization::LocIsSystemReadySrv, "/LocIsSystemReady", &serviceCbLocIsSystemReadySrv, this);
        m_srv_server_LocIsSystemReadySrv = rosServiceServer<sick_lidar_localization::LocIsSystemReadySrv>(srv_LocIsSystemReadySrv);
        auto srv_LocLoadMapToCacheSrv = ROS_CREATE_SRV_SERVER(nh, sick_lidar_localization::LocLoadMapToCacheSrv, "/LocLoadMapToCache", &serviceCbLocLoadMapToCacheSrv, this);
        m_srv_server_LocLoadMapToCacheSrv = rosServiceServer<sick_lidar_localization::LocLoadMapToCacheSrv>(srv_LocLoadMapToCacheSrv);
        auto srv_LocRequestTimestampSrv = ROS_CREATE_SRV_SERVER(nh, sick_lidar_localization::LocRequestTimestampSrv, "/LocRequestTimestamp", &serviceCbLocRequestTimestampSrv, this);
        m_srv_server_LocRequestTimestampSrv = rosServiceServer<sick_lidar_localization::LocRequestTimestampSrv>(srv_LocRequestTimestampSrv);
        auto srv_LocResumeAtPoseSrv = ROS_CREATE_SRV_SERVER(nh, sick_lidar_localization::LocResumeAtPoseSrv, "/LocResumeAtPose", &serviceCbLocResumeAtPoseSrv, this);
        m_srv_server_LocResumeAtPoseSrv = rosServiceServer<sick_lidar_localization::LocResumeAtPoseSrv>(srv_LocResumeAtPoseSrv);
        auto srv_LocSaveRingBufferRecordingSrv = ROS_CREATE_SRV_SERVER(nh, sick_lidar_localization::LocSaveRingBufferRecordingSrv, "/LocSaveRingBufferRecording", &serviceCbLocSaveRingBufferRecordingSrv, this);
        m_srv_server_LocSaveRingBufferRecordingSrv = rosServiceServer<sick_lidar_localization::LocSaveRingBufferRecordingSrv>(srv_LocSaveRingBufferRecordingSrv);
        auto srv_LocSetKinematicVehicleModelActiveSrv = ROS_CREATE_SRV_SERVER(nh, sick_lidar_localization::LocSetKinematicVehicleModelActiveSrv, "/LocSetKinematicVehicleModelActive", &serviceCbLocSetKinematicVehicleModelActiveSrv, this);
        m_srv_server_LocSetKinematicVehicleModelActiveSrv = rosServiceServer<sick_lidar_localization::LocSetKinematicVehicleModelActiveSrv>(srv_LocSetKinematicVehicleModelActiveSrv);
        auto srv_LocSetLinesForSupportActiveSrv = ROS_CREATE_SRV_SERVER(nh, sick_lidar_localization::LocSetLinesForSupportActiveSrv, "/LocSetLinesForSupportActive", &serviceCbLocSetLinesForSupportActiveSrv, this);
        m_srv_server_LocSetLinesForSupportActiveSrv = rosServiceServer<sick_lidar_localization::LocSetLinesForSupportActiveSrv>(srv_LocSetLinesForSupportActiveSrv);
        auto srv_LocSetMappingActiveSrv = ROS_CREATE_SRV_SERVER(nh, sick_lidar_localization::LocSetMappingActiveSrv, "/LocSetMappingActive", &serviceCbLocSetMappingActiveSrv, this);
        m_srv_server_LocSetMappingActiveSrv = rosServiceServer<sick_lidar_localization::LocSetMappingActiveSrv>(srv_LocSetMappingActiveSrv);
        auto srv_LocSetMapSrv = ROS_CREATE_SRV_SERVER(nh, sick_lidar_localization::LocSetMapSrv, "/LocSetMap", &serviceCbLocSetMapSrv, this);
        m_srv_server_LocSetMapSrv = rosServiceServer<sick_lidar_localization::LocSetMapSrv>(srv_LocSetMapSrv);
        auto srv_LocSetOdometryActiveSrv = ROS_CREATE_SRV_SERVER(nh, sick_lidar_localization::LocSetOdometryActiveSrv, "/LocSetOdometryActive", &serviceCbLocSetOdometryActiveSrv, this);
        m_srv_server_LocSetOdometryActiveSrv = rosServiceServer<sick_lidar_localization::LocSetOdometryActiveSrv>(srv_LocSetOdometryActiveSrv);
        auto srv_LocSetRecordingActiveSrv = ROS_CREATE_SRV_SERVER(nh, sick_lidar_localization::LocSetRecordingActiveSrv, "/LocSetRecordingActive", &serviceCbLocSetRecordingActiveSrv, this);
        m_srv_server_LocSetRecordingActiveSrv = rosServiceServer<sick_lidar_localization::LocSetRecordingActiveSrv>(srv_LocSetRecordingActiveSrv);
        auto srv_LocSetRingBufferRecordingActiveSrv = ROS_CREATE_SRV_SERVER(nh, sick_lidar_localization::LocSetRingBufferRecordingActiveSrv, "/LocSetRingBufferRecordingActive", &serviceCbLocSetRingBufferRecordingActiveSrv, this);
        m_srv_server_LocSetRingBufferRecordingActiveSrv = rosServiceServer<sick_lidar_localization::LocSetRingBufferRecordingActiveSrv>(srv_LocSetRingBufferRecordingActiveSrv);
        auto srv_LocStartLocalizingSrv = ROS_CREATE_SRV_SERVER(nh, sick_lidar_localization::LocStartLocalizingSrv, "/LocStartLocalizing", &serviceCbLocStartLocalizingSrv, this);
        m_srv_server_LocStartLocalizingSrv = rosServiceServer<sick_lidar_localization::LocStartLocalizingSrv>(srv_LocStartLocalizingSrv);
        auto srv_LocStopSrv = ROS_CREATE_SRV_SERVER(nh, sick_lidar_localization::LocStopSrv, "/LocStop", &serviceCbLocStopSrv, this);
        m_srv_server_LocStopSrv = rosServiceServer<sick_lidar_localization::LocStopSrv>(srv_LocStopSrv);
        auto srv_LocSwitchMapSrv = ROS_CREATE_SRV_SERVER(nh, sick_lidar_localization::LocSwitchMapSrv, "/LocSwitchMap", &serviceCbLocSwitchMapSrv, this);
        m_srv_server_LocSwitchMapSrv = rosServiceServer<sick_lidar_localization::LocSwitchMapSrv>(srv_LocSwitchMapSrv);
        auto srv_LocGetLocalizationStatusSrv = ROS_CREATE_SRV_SERVER(nh, sick_lidar_localization::LocGetLocalizationStatusSrv, "/LocGetLocalizationStatus", &serviceCbLocGetLocalizationStatusSrv, this);
        m_srv_server_LocGetLocalizationStatusSrv = rosServiceServer<sick_lidar_localization::LocGetLocalizationStatusSrv>(srv_LocGetLocalizationStatusSrv);
        auto srv_LocGetSoftwareVersionSrv = ROS_CREATE_SRV_SERVER(nh, sick_lidar_localization::LocGetSoftwareVersionSrv, "/LocGetSoftwareVersion", &serviceCbLocGetSoftwareVersionSrv, this);
        m_srv_server_LocGetSoftwareVersionSrv = rosServiceServer<sick_lidar_localization::LocGetSoftwareVersionSrv>(srv_LocGetSoftwareVersionSrv);
        auto srv_LocLoadPersistentConfigSrv = ROS_CREATE_SRV_SERVER(nh, sick_lidar_localization::LocLoadPersistentConfigSrv, "/LocLoadPersistentConfig", &serviceCbLocLoadPersistentConfigSrv, this);
        m_srv_server_LocLoadPersistentConfigSrv = rosServiceServer<sick_lidar_localization::LocLoadPersistentConfigSrv>(srv_LocLoadPersistentConfigSrv);
        //auto srv_LocSavePermanentSrv = ROS_CREATE_SRV_SERVER(nh, sick_lidar_localization::LocSavePermanentSrv, "/LocSavePermanent", &serviceCbLocSavePermanentSrv, this);
        //m_srv_server_LocSavePermanentSrv = rosServiceServer<sick_lidar_localization::LocSavePermanentSrv>(srv_LocSavePermanentSrv);
#endif // __ROS_VERSION > 0
    }
}

/*
 * @brief Returns default arguments of a service call. Example:
 *   std::string def_command, def_method, def_json;
 *   getDefaultCommand("LocIsSystemReady", def_command, def_method, def_json);
 *   std::cout << def_command << ", " << def_method << ", " << def_json << std::endl;
 * Output for "LocIsSystemReady" is "IsSystemReady, POST, {}"
 *   
 */
void sick_lidar_localization::SickServices::getDefaultCommand(const std::string& command, std::string& def_command, std::string& def_method, std::string& def_json)
{
    static std::map<std::string, std::vector<std::string>> command_map;
    if(command_map.empty())
    {
        command_map["LocGetErrorLevel"] = {"GetErrorLevel", "POST", "{}"};
        command_map["LocIsSystemReady"] = {"IsSystemReady", "POST", "{}"};
        command_map["LocAutoStartSavePose"] = {"LocAutoStartSavePose", "POST", "{}"};
        command_map["LocClearMapCache"] = {"LocClearMapCache", "POST", "{}"};
        command_map["LocGetMap"] = {"LocGetMap", "POST", "{}"};
        command_map["LocGetSystemState"] = {"LocGetSystemState", "POST", "{}"};
        command_map["LocInitializeAtPose"] = {"LocInitializeAtPose", "POST"};
        command_map["LocLoadMapToCache"] = {"LocLoadMapToCache", "POST"};
        command_map["LocRequestTimestamp"] = {"LocRequestTimestamp", "POST", "{}"};
        command_map["LocResumeAtPose"] = {"LocResumeAtPose", "POST"};
        command_map["LocSaveRingBufferRecording"] = {"LocSaveRingBufferRecording", "POST"};
        command_map["LocSetKinematicVehicleModelActive"] = {"LocSetKinematicVehicleModelActive", "POST"};
        command_map["LocSetLinesForSupportActive"] = {"LocSetLinesForSupportActive", "POST"};
        command_map["LocSetMap"] = {"LocSetMap", "POST"};
        command_map["LocSetMappingActive"] = {"LocSetMappingActive", "POST"};
        command_map["LocSetOdometryActive"] = {"LocSetOdometryActive", "POST"};
        command_map["LocSetRecordingActive"] = {"LocSetRecordingActive", "POST"};
        command_map["LocSetRingBufferRecordingActive"] = {"LocSetRingBufferRecordingActive", "POST"};
        command_map["LocStartLocalizing"] = {"LocStartLocalizing", "POST", "{}"};
        command_map["LocStop"] = {"LocStop", "POST", "{}"};
        command_map["LocSwitchMap"] = {"LocSwitchMap", "POST"};
        command_map["LocGetLocalizationStatus"] = {"LocGetLocalizationStatus", "POST"};
        command_map["LocGetSoftwareVersion"] = {"GetSoftwareVersion", "POST"};
        command_map["LocLoadPersistentConfig"] = {"LoadPersistentConfig", "POST"};
        //command_map["LocSavePermanent"] = {"SavePermanent", "POST", "{}"};
    }
    std::vector<std::string>& def_args = command_map[command];
    if(def_args.size() > 0)
        def_command = def_args[0];
    if(def_args.size() > 1)
        def_method = def_args[1];
    if(def_args.size() > 2)
        def_json = def_args[2];
}

std::map<std::string, sick_lidar_localization::JsonValue> sick_lidar_localization::SickServices::sendJsonRequestGetResponse(const std::string& command, const std::string& method, const std::string&json_data)
{
    std::string json_response = m_curl.send(command, method, json_data);
    std::map<std::string, sick_lidar_localization::JsonValue> response_data = sick_lidar_localization::JsonParser::parseRestResponseData(json_response);
    return response_data;
}

/*
 * @brief Sends a LocRequestTimestamp, updates the SoftwarePLL and returns LocRequestTimestamp response incl. send and receive timestamps
 */
sick_lidar_localization::LocRequestTimestampResponse sick_lidar_localization::SickServices::requestTimestamp(void)
{
    std::lock_guard<std::mutex> software_pll_lockguard(m_software_pll_mutex);

    // Send LocRequestTimestamp query
    std::string command = "LocRequestTimestamp", method = "POST", json_data = "{}";
    rosTime send_timestamp = rosTimeNow();
    std::map<std::string, sick_lidar_localization::JsonValue> response_data = sendJsonRequestGetResponse(command, method, json_data);
    rosTime recv_timestamp  = rosTimeNow();

    // Set timestamps in service_response, https://github.com/SICKAG/sick_lidar_localization/blob/1ce55facdb48eb13ac5ef6813b273ee1eaf00ba4/src/time_sync_service.cpp#L208
    LocRequestTimestampResponse service_response;
    int64_t lidar_timestamp = response_data["/data/timestamp"].toInt();
    service_response.timestamp_lidar_microsec = (uint32_t)lidar_timestamp;  // Lidar timestamp in microseconds from LocRequestTimestamp response
    service_response.send_time_vehicle_sec = sec(send_timestamp);           // Vehicle timestamp when sending LocRequestTimestamp (seconds part of ros timestamp immediately before tcp send)
    service_response.send_time_vehicle_nsec = nsec(send_timestamp);         // Vehicle timestamp when sending LocRequestTimestamp (nano seconds part of ros timestamp immediately before tcp send)
    service_response.receive_time_vehicle_sec = sec(recv_timestamp);        // Vehicle timestamp when receiving the LocRequestTimestamp response (seconds part of ros timestamp immediately after first response byte received)
    service_response.receive_time_vehicle_nsec = nsec(recv_timestamp);      // Vehicle timestamp when receiving the LocRequestTimestamp response (nano seconds part of ros timestamp immediately after first response byte received)

    // Calculate time offset, https://github.com/SICKAG/sick_lidar_localization/blob/1ce55facdb48eb13ac5ef6813b273ee1eaf00ba4/src/time_sync_service.cpp#L214
    uint64_t send_time_vehicle_nsec = service_response.send_time_vehicle_sec * 1000000000UL + service_response.send_time_vehicle_nsec;
    uint64_t receive_time_vehicle_nsec = service_response.receive_time_vehicle_sec * 1000000000UL + service_response.receive_time_vehicle_nsec;
    uint64_t mean_time_vehicle_nsec = send_time_vehicle_nsec / 2 + receive_time_vehicle_nsec / 2;
    service_response.mean_time_vehicle_microsec = mean_time_vehicle_nsec / 1000;                                      // Vehicle mean timestamp in microseconds: (send_time_vehicle + receive_time_vehicle) / 2
    service_response.delta_time_microsec = service_response.mean_time_vehicle_microsec - service_response.timestamp_lidar_microsec;  // Time offset: mean_time_vehicle_microsec - timestamp_lidar_microsec

    // Update software pll, https://github.com/SICKAG/sick_lidar_localization/blob/1ce55facdb48eb13ac5ef6813b273ee1eaf00ba4/src/time_sync_service.cpp#L242
    SoftwarePLL & software_pll_send_time = SoftwarePLL::Instance(m_software_pll_name_send_time, m_software_pll_fifo_length);
    SoftwarePLL & software_pll_receive_time = SoftwarePLL::Instance(m_software_pll_name_recv_time, m_software_pll_fifo_length);
    software_pll_send_time.UpdatePLL(service_response.send_time_vehicle_sec, service_response.send_time_vehicle_nsec, service_response.timestamp_lidar_microsec);
    software_pll_receive_time.UpdatePLL(service_response.receive_time_vehicle_sec, service_response.receive_time_vehicle_nsec, service_response.timestamp_lidar_microsec);

    ROS_INFO_STREAM("SickServices::requestTimestamp(\"" << command << "\", \"" << method << "\", \"" << json_data << "\"): timestamp=" << std::to_string(lidar_timestamp));
    return service_response;
}

/*
 * @brief Start a time sync thread to periodically request timestamps and to update Software PLL
 */
bool sick_lidar_localization::SickServices::startTimeSyncThread(void)
{
    m_time_sync_thread_running = true;
    m_time_sync_thread = new std::thread(&sick_lidar_localization::SickServices::runTimeSync, this);
    return m_time_sync_thread;
}

/*
 * @brief Stops the time sync thread to periodically request timestamps and to update Software PLL
 */
void sick_lidar_localization::SickServices::stopTimeSyncThread(void)
{
    m_time_sync_thread_running = false;
    if (m_time_sync_thread)
    {
        m_time_sync_thread->join();
        delete(m_time_sync_thread);
        m_time_sync_thread = 0;
    }
}

/*
 * @brief Runs periodically timestamp requests and updates the Software PLL
 */
bool sick_lidar_localization::SickServices::runTimeSync(void)
{
    for (int cnt = 0; cnt < m_time_sync_initial_length && rosOk() && m_time_sync_thread_running; cnt++)
    {
        sick_lidar_localization::LocRequestTimestampResponse timestamp_response = requestTimestamp();
        getSystemTimeFromTics(timestamp_response.timestamp_lidar_microsec, m_verbose);
        std::this_thread::sleep_for(std::chrono::duration<double, std::milli>(1000 / m_time_sync_initial_rate));
    }
    while (rosOk() && m_time_sync_thread_running)
    {
        sick_lidar_localization::LocRequestTimestampResponse timestamp_response = requestTimestamp();
        sick_lidar_localization::SyncTimeStamp timestamp_sync = getSystemTimeFromTics(timestamp_response.timestamp_lidar_microsec, m_verbose);
        checkDeltaTimestampToNow(timestamp_response.timestamp_lidar_microsec, timestamp_sync, 1);
        std::this_thread::sleep_for(std::chrono::duration<double, std::milli>(1000 / m_time_sync_rate));
    }
    m_time_sync_thread_running = false;
    return true;
}

/*
 * @brief Computes the difference between timestamp_sync and the current system time. Prints a warning and returns false, if delta time in seconds exceeds max_delta_time_seconds.
 */
bool sick_lidar_localization::SickServices::checkDeltaTimestampToNow(uint64_t lidar_tics_microsec, sick_lidar_localization::SyncTimeStamp& timestamp_sync, double max_delta_time_seconds)
{
    if (timestamp_sync.valid != 0)
    {
        rosTime system_now = rosTimeNow();
        int64_t system_now_nanoseconds = (int64_t)sec(system_now) * 1000000000 + (int64_t)nsec(system_now);
        int64_t timestamp_sync_nanoseconds = (int64_t)timestamp_sync.sec * 1000000000 + (int64_t)timestamp_sync.nsec;
        double delta_time_seconds = (double)(system_now_nanoseconds - timestamp_sync_nanoseconds) / 1000000000.0;
        if (std::abs(delta_time_seconds) > max_delta_time_seconds)
        {
            ROS_WARN_STREAM("## WARNING SickServices::runTimeSync(): lidar tics = " << lidar_tics_microsec
                << ", calculated timestamp from tics = " << timestamp_sync.sec << std::setw(3) << (timestamp_sync.nsec / 1000000) << " sec, "
                << "current systemtime: " << sec(system_now) << "." << nsec(system_now) << " sec, " << "delta time = " << delta_time_seconds << " seconds");
            return false;
        }
    }
    return true;
}

/*
 * @brief Calculates the system time of a vehicle pose from lidar ticks, using a software pll.
 * https://github.com/SICKAG/sick_lidar_localization/blob/1ce55facdb48eb13ac5ef6813b273ee1eaf00ba4/src/time_sync_service.cpp#L276
 * @param[in] lidar_tics_ms lidar tics
 * @param[in] verbose > 0 prints calculated time, otherwise silent mode
 * @return seconds and nanoseconds part of calculated time
 */
sick_lidar_localization::SyncTimeStamp sick_lidar_localization::SickServices::getSystemTimeFromTics(uint64_t lidar_tics_microsec, int verbose)
{
    sick_lidar_localization::SyncTimeStamp sync_timestamp = makeSyncTimeStamp(0, 0, false);
    std::lock_guard<std::mutex> software_pll_lockguard(m_software_pll_mutex);
    SoftwarePLL & software_pll_send_time = SoftwarePLL::Instance(m_software_pll_name_send_time, m_software_pll_fifo_length);
    SoftwarePLL & software_pll_receive_time = SoftwarePLL::Instance(m_software_pll_name_recv_time, m_software_pll_fifo_length);
    uint32_t system_timestamp_1_sec = 0, system_timestamp_1_nsec = 0, system_timestamp_2_sec = 0, system_timestamp_2_nsec = 0;
    if(software_pll_send_time.GetCorrectedTimeStamp(system_timestamp_1_sec, system_timestamp_1_nsec, lidar_tics_microsec)
        && software_pll_receive_time.GetCorrectedTimeStamp(system_timestamp_2_sec, system_timestamp_2_nsec, lidar_tics_microsec))
    {
        uint64_t system_nanoseconds_1 = (uint64_t)system_timestamp_1_sec * 1000000000 + (uint64_t)system_timestamp_1_nsec;
        uint64_t system_nanoseconds_2 = (uint64_t)system_timestamp_2_sec * 1000000000 + (uint64_t)system_timestamp_2_nsec;
        system_nanoseconds_2 = ((system_nanoseconds_2 >= system_nanoseconds_1) ? system_nanoseconds_2 : system_nanoseconds_1); // avoid overflow by jitter
        uint64_t system_nanoseconds = (system_nanoseconds_1 + system_nanoseconds_2) / 2;
        sync_timestamp.sec = (uint32_t)(system_nanoseconds / 1000000000);
        sync_timestamp.nsec = (uint32_t)(system_nanoseconds - 1000000000 * sync_timestamp.sec);
        sync_timestamp.valid = 1;
        if(verbose > 0)
        {
            rosTime system_now = rosTimeNow();
            ROS_INFO_STREAM("SickServices::getSystemTimeFromTics(): tics: " << lidar_tics_microsec << ", tics to systemtime: " 
                << sync_timestamp.sec << "." << std::setfill('0') << std::setw(3) << (sync_timestamp.nsec/1000000) << " sec."
                << ", current systemtime: " << sec(system_now) << "." << nsec(system_now) << " sec.");
        }
    }
    else if(software_pll_send_time.IsInitialized() && software_pll_receive_time.IsInitialized())
        ROS_WARN_STREAM("## ERROR SickServices::getSystemTimeFromTics(): SoftwarePLL::GetCorrectedTimeStamp() failed");
    else if(verbose > 0)
        ROS_INFO_STREAM("SickServices::getSystemTimeFromTics(): software pll still initializing");
    return sync_timestamp;
}

#if __ROS_VERSION > 0

bool sick_lidar_localization::SickServices::serviceCbLocAutoStartSavePoseSrvROS1(sick_lidar_localization::LocAutoStartSavePoseSrv::Request &service_request, sick_lidar_localization::LocAutoStartSavePoseSrv::Response &service_response)
{
    std::string command = "LocAutoStartSavePose", method = "POST", json_data = "{}";
    std::map<std::string, sick_lidar_localization::JsonValue> response_data = sendJsonRequestGetResponse(command, method, json_data);
    service_response.success = response_data["/data/success"].toBool();
    ROS_INFO_STREAM("SickServices::serviceCb(\"" << command << "\", \"" << method << "\", \"" << json_data << "\"): success=" << std::to_string(service_response.success));
    return true;
}
bool sick_lidar_localization::SickServices::serviceCbLocAutoStartSavePoseSrvROS2(std::shared_ptr<sick_lidar_localization::LocAutoStartSavePoseSrv::Request> service_request, std::shared_ptr<sick_lidar_localization::LocAutoStartSavePoseSrv::Response> service_response)
{
    return serviceCbLocAutoStartSavePoseSrvROS1(*service_request, *service_response);
}

bool sick_lidar_localization::SickServices::serviceCbLocClearMapCacheSrvROS1(sick_lidar_localization::LocClearMapCacheSrv::Request &service_request, sick_lidar_localization::LocClearMapCacheSrv::Response &service_response)
{
    std::string command = "LocClearMapCache", method = "POST", json_data = "{}";
    std::map<std::string, sick_lidar_localization::JsonValue> response_data = sendJsonRequestGetResponse(command, method, json_data);
    service_response.success = response_data["/data/success"].toBool();
    ROS_INFO_STREAM("SickServices::serviceCb(\"" << command << "\", \"" << method << "\", \"" << json_data << "\"): success=" << std::to_string(service_response.success));
    return true;
}
bool sick_lidar_localization::SickServices::serviceCbLocClearMapCacheSrvROS2(std::shared_ptr<sick_lidar_localization::LocClearMapCacheSrv::Request> service_request, std::shared_ptr<sick_lidar_localization::LocClearMapCacheSrv::Response> service_response)
{
    return serviceCbLocClearMapCacheSrvROS1(*service_request, *service_response);
}

bool sick_lidar_localization::SickServices::serviceCbLocGetErrorLevelSrvROS1(sick_lidar_localization::LocGetErrorLevelSrv::Request &service_request, sick_lidar_localization::LocGetErrorLevelSrv::Response &service_response)
{
    std::string command = "GetErrorLevel", method = "POST", json_data = "{}";
    std::map<std::string, sick_lidar_localization::JsonValue> response_data = sendJsonRequestGetResponse(command, method, json_data);
    service_response.success = (response_data.find("/data/level") != response_data.end() && response_data.find("/data/description") != response_data.end());
    service_response.level = (uint8_t)(response_data["/data/level"].toInt() & 0xFF);
    service_response.description = response_data["/data/description"].toString();
    ROS_INFO_STREAM("SickServices::serviceCb(\"" << command << "\", \"" << method << "\", \"" << json_data << "\"): level=" << std::to_string((int)service_response.level) << ", description=\"" << service_response.description << "\"");
    return true;
}
bool sick_lidar_localization::SickServices::serviceCbLocGetErrorLevelSrvROS2(std::shared_ptr<sick_lidar_localization::LocGetErrorLevelSrv::Request> service_request, std::shared_ptr<sick_lidar_localization::LocGetErrorLevelSrv::Response> service_response)
{
    return serviceCbLocGetErrorLevelSrvROS1(*service_request, *service_response);
}

bool sick_lidar_localization::SickServices::serviceCbLocGetMapSrvROS1(sick_lidar_localization::LocGetMapSrv::Request &service_request, sick_lidar_localization::LocGetMapSrv::Response &service_response)
{
    std::string command = "LocGetMap", method = "POST", json_data = "{}";
    std::map<std::string, sick_lidar_localization::JsonValue> response_data = sendJsonRequestGetResponse(command, method, json_data);
    service_response.success = (response_data.find("/data/mapPath") != response_data.end());
    service_response.mappath = response_data["/data/mapPath"].toString();
    ROS_INFO_STREAM("SickServices::serviceCb(\"" << command << "\", \"" << method << "\", \"" << json_data << "\"): mapPath=\"" << service_response.mappath << "\"");
    return true;
}
bool sick_lidar_localization::SickServices::serviceCbLocGetMapSrvROS2(std::shared_ptr<sick_lidar_localization::LocGetMapSrv::Request> service_request, std::shared_ptr<sick_lidar_localization::LocGetMapSrv::Response> service_response)
{
    return serviceCbLocGetMapSrvROS1(*service_request, *service_response);
}

bool sick_lidar_localization::SickServices::serviceCbLocGetSystemStateSrvROS1(sick_lidar_localization::LocGetSystemStateSrv::Request &service_request, sick_lidar_localization::LocGetSystemStateSrv::Response &service_response)
{
    std::string command = "LocGetSystemState", method = "POST", json_data = "{}";
    std::map<std::string, sick_lidar_localization::JsonValue> response_data = sendJsonRequestGetResponse(command, method, json_data);
    service_response.success = (response_data.find("/data/systemState") != response_data.end());
    service_response.systemstate = response_data["/data/systemState"].toString();
    ROS_INFO_STREAM("SickServices::serviceCb(\"" << command << "\", \"" << method << "\", \"" << json_data << "\"): systemState=\"" << service_response.systemstate << "\"");
    return true;
}
bool sick_lidar_localization::SickServices::serviceCbLocGetSystemStateSrvROS2(std::shared_ptr<sick_lidar_localization::LocGetSystemStateSrv::Request> service_request, std::shared_ptr<sick_lidar_localization::LocGetSystemStateSrv::Response> service_response)
{
    return serviceCbLocGetSystemStateSrvROS1(*service_request, *service_response);
}

bool sick_lidar_localization::SickServices::serviceCbLocInitializeAtPoseSrvROS1(sick_lidar_localization::LocInitializeAtPoseSrv::Request &service_request, sick_lidar_localization::LocInitializeAtPoseSrv::Response &service_response)
{
    std::string command = "LocInitializeAtPose", method = "POST", json_data = convertToJson(service_request);
    std::map<std::string, sick_lidar_localization::JsonValue> response_data = sendJsonRequestGetResponse(command, method, json_data);
    service_response.success = response_data["/data/success"].toBool();
    ROS_INFO_STREAM("SickServices::serviceCb(\"" << command << "\", \"" << method << "\", \"" << json_data << "\"): success=" << std::to_string(service_response.success));
    return true;
}
bool sick_lidar_localization::SickServices::serviceCbLocInitializeAtPoseSrvROS2(std::shared_ptr<sick_lidar_localization::LocInitializeAtPoseSrv::Request> service_request, std::shared_ptr<sick_lidar_localization::LocInitializeAtPoseSrv::Response> service_response)
{
    return serviceCbLocInitializeAtPoseSrvROS1(*service_request, *service_response);
}

bool sick_lidar_localization::SickServices::serviceCbLocIsSystemReadySrvROS1(sick_lidar_localization::LocIsSystemReadySrv::Request &service_request, sick_lidar_localization::LocIsSystemReadySrv::Response &service_response)
{
    std::string command = "IsSystemReady", method = "POST", json_data = "{}";
    std::map<std::string, sick_lidar_localization::JsonValue> response_data = sendJsonRequestGetResponse(command, method, json_data);
    service_response.success = response_data["/data/success"].toBool();
    ROS_INFO_STREAM("SickServices::serviceCb(\"" << command << "\", \"" << method << "\", \"" << json_data << "\"): success=" << std::to_string(service_response.success));
    return true;
}
bool sick_lidar_localization::SickServices::serviceCbLocIsSystemReadySrvROS2(std::shared_ptr<sick_lidar_localization::LocIsSystemReadySrv::Request> service_request, std::shared_ptr<sick_lidar_localization::LocIsSystemReadySrv::Response> service_response)
{
    return serviceCbLocIsSystemReadySrvROS1(*service_request, *service_response);
}

bool sick_lidar_localization::SickServices::serviceCbLocLoadMapToCacheSrvROS1(sick_lidar_localization::LocLoadMapToCacheSrv::Request &service_request, sick_lidar_localization::LocLoadMapToCacheSrv::Response &service_response)
{
    std::string command = "LocLoadMapToCache", method = "POST", json_data = convertToJson(service_request);
    std::map<std::string, sick_lidar_localization::JsonValue> response_data = sendJsonRequestGetResponse(command, method, json_data);
    service_response.success = response_data["/data/success"].toBool();
    ROS_INFO_STREAM("SickServices::serviceCb(\"" << command << "\", \"" << method << "\", \"" << json_data << "\"): success=" << std::to_string(service_response.success));
    return true;
}
bool sick_lidar_localization::SickServices::serviceCbLocLoadMapToCacheSrvROS2(std::shared_ptr<sick_lidar_localization::LocLoadMapToCacheSrv::Request> service_request, std::shared_ptr<sick_lidar_localization::LocLoadMapToCacheSrv::Response> service_response)
{
    return serviceCbLocLoadMapToCacheSrvROS1(*service_request, *service_response);
}

bool sick_lidar_localization::SickServices::serviceCbLocRequestTimestampSrvROS1(sick_lidar_localization::LocRequestTimestampSrv::Request &service_request, sick_lidar_localization::LocRequestTimestampSrv::Response &service_response)
{
    sick_lidar_localization::LocRequestTimestampResponse response = requestTimestamp();
    service_response.timestamp_lidar_microsec = response.timestamp_lidar_microsec;      // Lidar timestamp in microseconds from LocRequestTimestamp response
    service_response.send_time_vehicle_sec = response.send_time_vehicle_sec;            // Vehicle timestamp when sending LocRequestTimestamp (seconds part of ros timestamp immediately before tcp send)
    service_response.send_time_vehicle_nsec = response.send_time_vehicle_nsec;          // Vehicle timestamp when sending LocRequestTimestamp (nano seconds part of ros timestamp immediately before tcp send)
    service_response.receive_time_vehicle_sec = response.receive_time_vehicle_sec;      // Vehicle timestamp when receiving the LocRequestTimestamp response (seconds part of ros timestamp immediately after first response byte received)
    service_response.receive_time_vehicle_nsec = response.receive_time_vehicle_nsec;    // Vehicle timestamp when receiving the LocRequestTimestamp response (nano seconds part of ros timestamp immediately after first response byte received)
    service_response.mean_time_vehicle_microsec = response.mean_time_vehicle_microsec;  // Vehicle mean timestamp in microseconds: (send_time_vehicle + receive_time_vehicle) / 2
    service_response.delta_time_microsec = response.delta_time_microsec;                // Time offset: mean_time_vehicle_microsec - timestamp_lidar_microsec
    return true;
}
bool sick_lidar_localization::SickServices::serviceCbLocRequestTimestampSrvROS2(std::shared_ptr<sick_lidar_localization::LocRequestTimestampSrv::Request> service_request, std::shared_ptr<sick_lidar_localization::LocRequestTimestampSrv::Response> service_response)
{
    return serviceCbLocRequestTimestampSrvROS1(*service_request, *service_response);
}

bool sick_lidar_localization::SickServices::serviceCbLocResumeAtPoseSrvROS1(sick_lidar_localization::LocResumeAtPoseSrv::Request &service_request, sick_lidar_localization::LocResumeAtPoseSrv::Response &service_response)
{
    std::string command = "LocResumeAtPose", method = "POST", json_data = convertToJson(service_request);
    std::map<std::string, sick_lidar_localization::JsonValue> response_data = sendJsonRequestGetResponse(command, method, json_data);
    service_response.success = response_data["/data/success"].toBool();
    ROS_INFO_STREAM("SickServices::serviceCb(\"" << command << "\", \"" << method << "\", \"" << json_data << "\"): success=" << std::to_string(service_response.success));
    return true;
}
bool sick_lidar_localization::SickServices::serviceCbLocResumeAtPoseSrvROS2(std::shared_ptr<sick_lidar_localization::LocResumeAtPoseSrv::Request> service_request, std::shared_ptr<sick_lidar_localization::LocResumeAtPoseSrv::Response> service_response)
{
    return serviceCbLocResumeAtPoseSrvROS1(*service_request, *service_response);
}

bool sick_lidar_localization::SickServices::serviceCbLocSaveRingBufferRecordingSrvROS1(sick_lidar_localization::LocSaveRingBufferRecordingSrv::Request &service_request, sick_lidar_localization::LocSaveRingBufferRecordingSrv::Response &service_response)
{
    std::string command = "LocSaveRingBufferRecording", method = "POST", json_data = convertToJson(service_request);
    std::map<std::string, sick_lidar_localization::JsonValue> response_data = sendJsonRequestGetResponse(command, method, json_data);
    service_response.success = response_data["/data/success"].toBool();
    ROS_INFO_STREAM("SickServices::serviceCb(\"" << command << "\", \"" << method << "\", \"" << json_data << "\"): success=" << std::to_string(service_response.success));
    return true;
}
bool sick_lidar_localization::SickServices::serviceCbLocSaveRingBufferRecordingSrvROS2(std::shared_ptr<sick_lidar_localization::LocSaveRingBufferRecordingSrv::Request> service_request, std::shared_ptr<sick_lidar_localization::LocSaveRingBufferRecordingSrv::Response> service_response)
{
    return serviceCbLocSaveRingBufferRecordingSrvROS1(*service_request, *service_response);
}

bool sick_lidar_localization::SickServices::serviceCbLocSetKinematicVehicleModelActiveSrvROS1(sick_lidar_localization::LocSetKinematicVehicleModelActiveSrv::Request &service_request, sick_lidar_localization::LocSetKinematicVehicleModelActiveSrv::Response &service_response)
{
    std::string command = "LocSetKinematicVehicleModelActive", method = "POST", json_data = convertToJson(service_request);
    std::map<std::string, sick_lidar_localization::JsonValue> response_data = sendJsonRequestGetResponse(command, method, json_data);
    service_response.success = response_data["/data/success"].toBool();
    ROS_INFO_STREAM("SickServices::serviceCb(\"" << command << "\", \"" << method << "\", \"" << json_data << "\"): success=" << std::to_string(service_response.success));
    return true;
}
bool sick_lidar_localization::SickServices::serviceCbLocSetKinematicVehicleModelActiveSrvROS2(std::shared_ptr<sick_lidar_localization::LocSetKinematicVehicleModelActiveSrv::Request> service_request, std::shared_ptr<sick_lidar_localization::LocSetKinematicVehicleModelActiveSrv::Response> service_response)
{
    return serviceCbLocSetKinematicVehicleModelActiveSrvROS1(*service_request, *service_response);
}

bool sick_lidar_localization::SickServices::serviceCbLocSetLinesForSupportActiveSrvROS1(sick_lidar_localization::LocSetLinesForSupportActiveSrv::Request &service_request, sick_lidar_localization::LocSetLinesForSupportActiveSrv::Response &service_response)
{
    std::string command = "LocSetLinesForSupportActive", method = "POST", json_data = convertToJson(service_request);
    std::map<std::string, sick_lidar_localization::JsonValue> response_data = sendJsonRequestGetResponse(command, method, json_data);
    service_response.success = response_data["/data/success"].toBool();
    ROS_INFO_STREAM("SickServices::serviceCb(\"" << command << "\", \"" << method << "\", \"" << json_data << "\"): success=" << std::to_string(service_response.success));
    return true;
}
bool sick_lidar_localization::SickServices::serviceCbLocSetLinesForSupportActiveSrvROS2(std::shared_ptr<sick_lidar_localization::LocSetLinesForSupportActiveSrv::Request> service_request, std::shared_ptr<sick_lidar_localization::LocSetLinesForSupportActiveSrv::Response> service_response)
{
    return serviceCbLocSetLinesForSupportActiveSrvROS1(*service_request, *service_response);
}

bool sick_lidar_localization::SickServices::serviceCbLocSetMappingActiveSrvROS1(sick_lidar_localization::LocSetMappingActiveSrv::Request &service_request, sick_lidar_localization::LocSetMappingActiveSrv::Response &service_response)
{
    std::string command = "LocSetMappingActive", method = "POST", json_data = convertToJson(service_request);
    std::map<std::string, sick_lidar_localization::JsonValue> response_data = sendJsonRequestGetResponse(command, method, json_data);
    service_response.success = response_data["/data/success"].toBool();
    ROS_INFO_STREAM("SickServices::serviceCb(\"" << command << "\", \"" << method << "\", \"" << json_data << "\"): success=" << std::to_string(service_response.success));
    return true;
}
bool sick_lidar_localization::SickServices::serviceCbLocSetMappingActiveSrvROS2(std::shared_ptr<sick_lidar_localization::LocSetMappingActiveSrv::Request> service_request, std::shared_ptr<sick_lidar_localization::LocSetMappingActiveSrv::Response> service_response)
{
    return serviceCbLocSetMappingActiveSrvROS1(*service_request, *service_response);
}

bool sick_lidar_localization::SickServices::serviceCbLocSetMapSrvROS1(sick_lidar_localization::LocSetMapSrv::Request &service_request, sick_lidar_localization::LocSetMapSrv::Response &service_response)
{
    std::string command = "LocSetMap", method = "POST", json_data = convertToJson(service_request);
    std::map<std::string, sick_lidar_localization::JsonValue> response_data = sendJsonRequestGetResponse(command, method, json_data);
    service_response.success = response_data["/data/success"].toBool();
    ROS_INFO_STREAM("SickServices::serviceCb(\"" << command << "\", \"" << method << "\", \"" << json_data << "\"): success=" << std::to_string(service_response.success));
    return true;
}
bool sick_lidar_localization::SickServices::serviceCbLocSetMapSrvROS2(std::shared_ptr<sick_lidar_localization::LocSetMapSrv::Request> service_request, std::shared_ptr<sick_lidar_localization::LocSetMapSrv::Response> service_response)
{
    return serviceCbLocSetMapSrvROS1(*service_request, *service_response);
}

bool sick_lidar_localization::SickServices::serviceCbLocSetOdometryActiveSrvROS1(sick_lidar_localization::LocSetOdometryActiveSrv::Request &service_request, sick_lidar_localization::LocSetOdometryActiveSrv::Response &service_response)
{
    std::string command = "LocSetOdometryActive", method = "POST", json_data = convertToJson(service_request);
    std::map<std::string, sick_lidar_localization::JsonValue> response_data = sendJsonRequestGetResponse(command, method, json_data);
    service_response.success = response_data["/data/success"].toBool();
    ROS_INFO_STREAM("SickServices::serviceCb(\"" << command << "\", \"" << method << "\", \"" << json_data << "\"): success=" << std::to_string(service_response.success));
    return true;
}
bool sick_lidar_localization::SickServices::serviceCbLocSetOdometryActiveSrvROS2(std::shared_ptr<sick_lidar_localization::LocSetOdometryActiveSrv::Request> service_request, std::shared_ptr<sick_lidar_localization::LocSetOdometryActiveSrv::Response> service_response)
{
    return serviceCbLocSetOdometryActiveSrvROS1(*service_request, *service_response);
}

bool sick_lidar_localization::SickServices::serviceCbLocSetRecordingActiveSrvROS1(sick_lidar_localization::LocSetRecordingActiveSrv::Request &service_request, sick_lidar_localization::LocSetRecordingActiveSrv::Response &service_response)
{
    std::string command = "LocSetRecordingActive", method = "POST", json_data = convertToJson(service_request);
    std::map<std::string, sick_lidar_localization::JsonValue> response_data = sendJsonRequestGetResponse(command, method, json_data);
    service_response.success = response_data["/data/success"].toBool();
    ROS_INFO_STREAM("SickServices::serviceCb(\"" << command << "\", \"" << method << "\", \"" << json_data << "\"): success=" << std::to_string(service_response.success));
    return true;
}
bool sick_lidar_localization::SickServices::serviceCbLocSetRecordingActiveSrvROS2(std::shared_ptr<sick_lidar_localization::LocSetRecordingActiveSrv::Request> service_request, std::shared_ptr<sick_lidar_localization::LocSetRecordingActiveSrv::Response> service_response)
{
    return serviceCbLocSetRecordingActiveSrvROS1(*service_request, *service_response);
}

bool sick_lidar_localization::SickServices::serviceCbLocSetRingBufferRecordingActiveSrvROS1(sick_lidar_localization::LocSetRingBufferRecordingActiveSrv::Request &service_request, sick_lidar_localization::LocSetRingBufferRecordingActiveSrv::Response &service_response)
{
    std::string command = "LocSetRingBufferRecordingActive", method = "POST", json_data = convertToJson(service_request);
    std::map<std::string, sick_lidar_localization::JsonValue> response_data = sendJsonRequestGetResponse(command, method, json_data);
    service_response.success = response_data["/data/success"].toBool();
    ROS_INFO_STREAM("SickServices::serviceCb(\"" << command << "\", \"" << method << "\", \"" << json_data << "\"): success=" << std::to_string(service_response.success));
    return true;
}
bool sick_lidar_localization::SickServices::serviceCbLocSetRingBufferRecordingActiveSrvROS2(std::shared_ptr<sick_lidar_localization::LocSetRingBufferRecordingActiveSrv::Request> service_request, std::shared_ptr<sick_lidar_localization::LocSetRingBufferRecordingActiveSrv::Response> service_response)
{
    return serviceCbLocSetRingBufferRecordingActiveSrvROS1(*service_request, *service_response);
}

bool sick_lidar_localization::SickServices::serviceCbLocStartLocalizingSrvROS1(sick_lidar_localization::LocStartLocalizingSrv::Request &service_request, sick_lidar_localization::LocStartLocalizingSrv::Response &service_response)
{
    std::string command = "LocStartLocalizing", method = "POST", json_data = "{}";
    std::map<std::string, sick_lidar_localization::JsonValue> response_data = sendJsonRequestGetResponse(command, method, json_data);
    service_response.success = response_data["/data/success"].toBool();
    ROS_INFO_STREAM("SickServices::serviceCb(\"" << command << "\", \"" << method << "\", \"" << json_data << "\"): success=" << std::to_string(service_response.success));
    return true;
}
bool sick_lidar_localization::SickServices::serviceCbLocStartLocalizingSrvROS2(std::shared_ptr<sick_lidar_localization::LocStartLocalizingSrv::Request> service_request, std::shared_ptr<sick_lidar_localization::LocStartLocalizingSrv::Response> service_response)
{
    return serviceCbLocStartLocalizingSrvROS1(*service_request, *service_response);
}

bool sick_lidar_localization::SickServices::serviceCbLocStopSrvROS1(sick_lidar_localization::LocStopSrv::Request &service_request, sick_lidar_localization::LocStopSrv::Response &service_response)
{
    std::string command = "LocStop", method = "POST", json_data = "{}";
    std::map<std::string, sick_lidar_localization::JsonValue> response_data = sendJsonRequestGetResponse(command, method, json_data);
    service_response.success = response_data["/data/success"].toBool();
    ROS_INFO_STREAM("SickServices::serviceCb(\"" << command << "\", \"" << method << "\", \"" << json_data << "\"): success=" << std::to_string(service_response.success));
    return true;
}
bool sick_lidar_localization::SickServices::serviceCbLocStopSrvROS2(std::shared_ptr<sick_lidar_localization::LocStopSrv::Request> service_request, std::shared_ptr<sick_lidar_localization::LocStopSrv::Response> service_response)
{
    return serviceCbLocStopSrvROS1(*service_request, *service_response);
}

bool sick_lidar_localization::SickServices::serviceCbLocSwitchMapSrvROS1(sick_lidar_localization::LocSwitchMapSrv::Request &service_request, sick_lidar_localization::LocSwitchMapSrv::Response &service_response)
{
    std::string command = "LocSwitchMap", method = "POST", json_data = convertToJson(service_request);
    std::map<std::string, sick_lidar_localization::JsonValue> response_data = sendJsonRequestGetResponse(command, method, json_data);
    service_response.success = response_data["/data/success"].toBool();
    ROS_INFO_STREAM("SickServices::serviceCb(\"" << command << "\", \"" << method << "\", \"" << json_data << "\"): success=" << std::to_string(service_response.success));
    return true;
}
bool sick_lidar_localization::SickServices::serviceCbLocSwitchMapSrvROS2(std::shared_ptr<sick_lidar_localization::LocSwitchMapSrv::Request> service_request, std::shared_ptr<sick_lidar_localization::LocSwitchMapSrv::Response> service_response)
{
    return serviceCbLocSwitchMapSrvROS1(*service_request, *service_response);
}

bool sick_lidar_localization::SickServices::serviceCbLocGetLocalizationStatusSrvROS1(sick_lidar_localization::LocGetLocalizationStatusSrv::Request &service_request, sick_lidar_localization::LocGetLocalizationStatusSrv::Response &service_response)
{
    std::string command = "LocGetLocalizationStatus", method = "POST", json_data = "{}";
    std::map<std::string, sick_lidar_localization::JsonValue> response_data = sendJsonRequestGetResponse(command, method, json_data);
    service_response.success = (response_data.find("/data/locStatus") != response_data.end() && response_data.find("/data/details") != response_data.end());
    service_response.locstatus = (uint8_t)(response_data["/data/locStatus"].toInt() & 0xFF);
    service_response.details = response_data["/data/details"].toString();
    ROS_INFO_STREAM("SickServices::serviceCb(\"" << command << "\", \"" << method << "\", \"" << json_data << "\"): success=" << std::to_string(service_response.success));
    return true;
}
bool sick_lidar_localization::SickServices::serviceCbLocGetLocalizationStatusSrvROS2(std::shared_ptr<sick_lidar_localization::LocGetLocalizationStatusSrv::Request> service_request, std::shared_ptr<sick_lidar_localization::LocGetLocalizationStatusSrv::Response> service_response)
{
    return serviceCbLocGetLocalizationStatusSrvROS1(*service_request, *service_response);
}

bool sick_lidar_localization::SickServices::serviceCbLocGetSoftwareVersionSrvROS1(sick_lidar_localization::LocGetSoftwareVersionSrv::Request &service_request, sick_lidar_localization::LocGetSoftwareVersionSrv::Response &service_response)
{
    std::string command = "GetSoftwareVersion", method = "POST", json_data = "{}";
    std::map<std::string, sick_lidar_localization::JsonValue> response_data = sendJsonRequestGetResponse(command, method, json_data);
    service_response.success = (response_data.find("/data/version") != response_data.end());
    service_response.version = response_data["/data/version"].toString();
    ROS_INFO_STREAM("SickServices::serviceCb(\"" << command << "\", \"" << method << "\", \"" << json_data << "\"): success=" << std::to_string(service_response.success));
    return true;
}
bool sick_lidar_localization::SickServices::serviceCbLocGetSoftwareVersionSrvROS2(std::shared_ptr<sick_lidar_localization::LocGetSoftwareVersionSrv::Request> service_request, std::shared_ptr<sick_lidar_localization::LocGetSoftwareVersionSrv::Response> service_response)
{
    return serviceCbLocGetSoftwareVersionSrvROS1(*service_request, *service_response);
}

bool sick_lidar_localization::SickServices::serviceCbLocLoadPersistentConfigSrvROS1(sick_lidar_localization::LocLoadPersistentConfigSrv::Request &service_request, sick_lidar_localization::LocLoadPersistentConfigSrv::Response &service_response)
{
    std::string command = "LoadPersistentConfig", method = "POST", json_data = "{}";
    std::map<std::string, sick_lidar_localization::JsonValue> response_data = sendJsonRequestGetResponse(command, method, json_data);
    service_response.success = response_data["/data/success"].toBool();
    service_response.response = response_data["/data/response"].toString();
    ROS_INFO_STREAM("SickServices::serviceCb(\"" << command << "\", \"" << method << "\", \"" << json_data << "\"): success=" << std::to_string(service_response.success));
    return true;
}
bool sick_lidar_localization::SickServices::serviceCbLocLoadPersistentConfigSrvROS2(std::shared_ptr<sick_lidar_localization::LocLoadPersistentConfigSrv::Request> service_request, std::shared_ptr<sick_lidar_localization::LocLoadPersistentConfigSrv::Response> service_response)
{
    return serviceCbLocLoadPersistentConfigSrvROS1(*service_request, *service_response);
}

//bool sick_lidar_localization::SickServices::serviceCbLocSavePermanentSrvROS1(sick_lidar_localization::LocSavePermanentSrv::Request &service_request, sick_lidar_localization::LocSavePermanentSrv::Response &service_response)
//{
//    std::string command = "SavePermanent", method = "POST", json_data = "{}";
//    std::map<std::string, sick_lidar_localization::JsonValue> response_data = sendJsonRequestGetResponse(command, method, json_data);
//    service_response.success = response_data["/data/success"].toBool();
//    ROS_INFO_STREAM("SickServices::serviceCb(\"" << command << "\", \"" << method << "\", \"" << json_data << "\"): success=" << std::to_string(service_response.success));
//    return true;
//}
//bool sick_lidar_localization::SickServices::serviceCbLocSavePermanentSrvROS2(std::shared_ptr<sick_lidar_localization::LocSavePermanentSrv::Request> service_request, std::shared_ptr<sick_lidar_localization::LocSavePermanentSrv::Response> service_response)
//{
//    return serviceCbLocSavePermanentSrvROS1(*service_request, *service_response);
//}

std::string sick_lidar_localization::SickServices::convertToJson(bool val)
{
    return (val ? "true" : "false");
}

std::string sick_lidar_localization::SickServices::convertToJson(sick_lidar_localization::LocInitializeAtPoseSrv::Request &request)
{
    std::stringstream json;
    json << "{\"data\":{\"pose\":{\"x\":" << request.x << ",\"y\":" << request.y << ",\"yaw\":" << request.yaw << "},\"searchRadius\":" << request.searchradius << "}}";
    return json.str();
}

std::string sick_lidar_localization::SickServices::convertToJson(sick_lidar_localization::LocLoadMapToCacheSrv::Request &request)
{
    std::stringstream json;
    json << "{\"data\":{\"mapPath\":\"" << request.mappath << "\"}}";
    return json.str();
}

std::string sick_lidar_localization::SickServices::convertToJson(sick_lidar_localization::LocResumeAtPoseSrv::Request &request)
{
    std::stringstream json;
    json << "{\"data\":{\"pose\":{\"x\":" << request.x << ",\"y\":" << request.y << ",\"yaw\":" << request.yaw << "}}}";
    return json.str();
}

std::string sick_lidar_localization::SickServices::convertToJson(sick_lidar_localization::LocSaveRingBufferRecordingSrv::Request &request)
{
    std::stringstream json;
    json << "{\"data\":{\"reason\":\"" << request.reason << "\"}}";
    return json.str();
}

std::string sick_lidar_localization::SickServices::convertToJson(sick_lidar_localization::LocSetKinematicVehicleModelActiveSrv::Request &request)
{
    std::stringstream json;
    json << "{\"data\":{\"active\":" << convertToJson(request.active) << "}}";
    return json.str();
}

std::string sick_lidar_localization::SickServices::convertToJson(sick_lidar_localization::LocSetLinesForSupportActiveSrv::Request &request)
{
    std::stringstream json;
    json << "{\"data\":{\"active\":" << convertToJson(request.active) << "}}";
    return json.str();
}

std::string sick_lidar_localization::SickServices::convertToJson(sick_lidar_localization::LocSetMappingActiveSrv::Request &request)
{
    std::stringstream json;
    json << "{\"data\":{\"active\":" << convertToJson(request.active) << "}}";
    return json.str();
}

std::string sick_lidar_localization::SickServices::convertToJson(sick_lidar_localization::LocSetMapSrv::Request &request)
{
    std::stringstream json;
    json << "{\"data\":{\"mapPath\":\"" << request.mappath << "\"}}";
    return json.str();
}

std::string sick_lidar_localization::SickServices::convertToJson(sick_lidar_localization::LocSetOdometryActiveSrv::Request &request)
{
    std::stringstream json;
    json << "{\"data\":{\"active\":" << convertToJson(request.active) << "}}";
    return json.str();
}

std::string sick_lidar_localization::SickServices::convertToJson(sick_lidar_localization::LocSetRecordingActiveSrv::Request &request)
{
    std::stringstream json;
    json << "{\"data\":{\"active\":" << convertToJson(request.active) << "}}";
    return json.str();
}

std::string sick_lidar_localization::SickServices::convertToJson(sick_lidar_localization::LocSetRingBufferRecordingActiveSrv::Request &request)
{
    std::stringstream json;
    json << "{\"data\":{\"active\":" << convertToJson(request.active) << "}}";
    return json.str();
}

std::string sick_lidar_localization::SickServices::convertToJson(sick_lidar_localization::LocSwitchMapSrv::Request &request)
{
    std::stringstream json;
    json << "{\"data\":{\"subMapName\":\"" << request.submapname << "\"}}";
    return json.str();
}

#endif // __ROS_VERSION > 0
